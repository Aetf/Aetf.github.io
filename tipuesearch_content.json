{"pages":[{"tags":"pages","title":"Page Not Found","text":"Oops! The page you were looking for was not found.","url":"https://unlimitedcodeworks.xyz/page-not-found/"},{"tags":"misc","title":"GSoC 2016: LLDB Support for KDevelop","text":"I've always wanted to participate the Google Code of Summer . It's cool and an super legitimate experience to put on CV, isn't it? Anyway, what's more exciting is that my first time proposal was accepted! So I think it might be a good chance to also post this on the blog, which may probably keeps me writing more things and make the blog more... I mean, make it less like unmaintained XD The big plan is, writing a series of articles as the project goes on and making them kind of status updates. Let see how far I can go though :P Introduction Enabling KDevelop to use LLDB as a debugging backend, which would be especially useful on Max OS X and Windows, where gdb support is rather scarce, and it can also help people that want to switch to lldb on linux (like me!) by adding decent IDE support. Project Goals LLDB support in similar feature-completeness as current GDB support. The user should be able to select what debugger to use intuitively on a per launch configuration base. The following function should be supported. Debug session management: begin, kill, restart Set breakpoints breakpoint list enable/disable breakpoints conditional breakpoints Information inspection Frame Stack: threads, call stack Local variables Symbol info when hovering mouse over the symbol Disassembler Register Debug commands: next, step, jump, run to the end of function, arbitrary lldb command Attach to a running process Examine core file Remote debug Drkonqi support Implementation The whole work can be broken down to three major parts. Communication with LLDB : Implement a wrapper class that hides all hassles communicating with LLDB and provide a consistent api that is agnostic to specific communication methods, be it inter-processes or direct library link. LLDB Specific Classes : Implementation of LLDB specific controllers and manager classes. This includes DebugSession and friends, *Controller classes and config page factories. This part is higher level than the first one, but still remains LLDB specific, thus must be implemented separately from GDB variants. UI and Other : Hook the UI with the LLDB backend built from the above two parts. This part has the potential to share a large amount of code with GDB. However, currently all UI widgets are bounded to GDB backend. Thus refactors on these classes are needed to split common code out. Relation with current GDB Plugin Right now the debugger code in kdevplatform only provides very basic facilities to build a debug plugin. Most heavey works are still done in GDBDebugger::CppDebuggerPlugin . An investigation into the code shows that there are planty part of code that is debugger backend agnostic, and could be reused by LLDB plugin. The ideal/desired design would be extract all debugger backend agnostic into kdevplatform and let GDB and LLDB plugin built on top of that. But we risk breaking the existing GDB plugin which already does a good job. Therefore, I plan to first focus on implementation of LLDB plugin with a copy of all needed classes in kdevplatform, and only after the LLDB plugin reaches a rather mature state, shall we begin port GDB to use the new infrastructure. Communication with LLDB This can be done by expose a interface class with all available lldb commands and internally delegate the command execution to one of the LLDB interface mentioned below. Other parts of the LLDB debugger plugin will rely solely on the interface class to post lldb commands/jobs. This design is similar to what is used in GDBDebugger::CppDebuggerPlugin . This is the foundation of all other parts of the plugin, so I plan to make this part solid by my best effect before moving on to the next part. Possible LLDB Interface to Use LLDB released LLDB-MI on 2014, and there is another project LLDBMI2 that does the same thing. Along with those, there is the good old C++ API. Further investigation and evaluation is needed to finally determine on which one to use. Here just list a brief description of each choise. LLDB-MI Included in the LLDB source code, which means better support A good separation of input/factory/output Seems only support remote debugging Limited command implemented at the time of the blog written (might have been changed since then) LLDBMI2 Seems to be a simple MI interface to LLDB, which is more lightweight than LLDB-MI Not official but actively maintained Only support local debugging and only support Mac OS X C++ API Directly link to LLDB, which should be fast and the API is mature Must find a way to protect ourselves from debugger crashes Write from scratch, can't reuse MI code for GDB Implement LLDB Specific Classes These classes is higher level than the above, and is the major classes that teach KDevelop how to use LLDB to debug. IDebugSession represents a specific debug session with a debugger of some type. Currently GDBDebugger provides an implementation DebugSession , but it contains GDB specific code. The same applies to other classes such as BreakpointController and FrameStackModel . LLDB of course should be configured differently than GDB. Currently, the user can tune various options for GDB in the launcher configuration page. This should be extended to let the user change the debugger used for a particular debug launcher and configure separately. Here is a brief list of related classes DebugSession BreakpointController VariableController FrameStackModel ConfigPageFactory Launcher and jobs DebugJob Move non GDB Specific Classes to KDevPlatform As said above, the GDBDebugger plugin contains many non GDB specific code. Rather than rewrite the same thing for LLDB debugger plugin, I plan to reuse these code as much as possible. This includes UI widgets for different tool views, context menu items and dialogs. Drkonqi and the glue code between user action and IDebugSession methods are other parts that can be potentially reused. UI ToolViews RegisterView DisassembleWidget GDBOutputWidget MemoryViewDlg Context Menu Dialogs DebugTracingDialog SelectCoreDialog ProcessSelection Drkonqi DebugSession management PretteyPrinters These scripts are used to make C++/STL and Qt objects easier for the user to read. Currently I'm not sure if they are still needed for LLDB. If so, this might need to be ported to LLDB data formatters. Tests The importance of tests can never be over emphasized. I'm going to start with the same unit tests as GDB when applicable and add other tests when find problems during the implementation. Timeline Milestones April 22 (2 weeks): If accepted, I will start by contributing little bug fixes to KDevelop to get familiar with the code base. Besides that, the most work for this period will be investigating and playing with different ways to talk with lldb. It is important to have this period before actually starting coding, as the decision of which LLDB interface to use would affect the overall stability and quality of the plugin, and it deserves some careful thought. May 6 (3.5 weeks): Around this time, I should have done some demos on talking to LLDB. Use this experience gained from previous weeks, I will start actually build the communication infrastructure with LLDB. This could be a totally rewrite from stratch or an extension of the previous demo depends on what method I choose. May 31 (3 weeks): We should have a final communication infrastructure with LLDB (part 1) now. And based on that, I can start implement most of the important controllers and managers for the plugin, including IPlugin , IDebugSession and friends. June 21 (4 weeks): Most of the important controllers and mangers (part 2) should have been implemented at this time. Although they may still contain stub methods which are related to UI setups and Drkonqi. I give this period the longest time because in my opinion, it is the UI that actually talks to users, and any small bug in it will frustrate them. Thus I not only need to implement them, but also polish them to some extent. July 19 (4 weeks): The whole plugin should work for simple use cases by then. And the last 4 weeks are used to revise and finialize the code to fix any remaining bugs as well as move non GDB specific classes into kdevplatform.git. This period also serves as a buffer as we are always optimistic in estimating works and it always turns out to take longer! Augest 15 : Fine tune and bug fixes done, project finish. Availability I will stay at the university for research during the summer break, which basically is another project to do. However, the time schedule for the research is flexible, and two project at the same time is the regular workload for a normal semaster. So I believe I can manage my time accrodingly and there shouldn't be a problem. About me My name is Peifeng Yu, a master student at the University of Michigan majoring in Computer Science. I've been using KDE as my major desktop for years and really enjoy the amount of customization it allows. As a programmer, I use KDevelop for most of my projects because of its better support for CMake based projects (and yes, sometimes QtCreator if I'm using qmake ;-) ). I was excited when it first announced the integration with clang compiler. Now here's opportunity to integrate further with llvm toolchain and it would be exciting if I can contribute to it. As for the skills, I've been programming in C++ for about 5 years and it's my favorite language. I consider myself an experienced C++ programmer thanks to my experience on ACM/ICPC during my undergraduate, which sharpened my program skills and helped me gain more insight in algorithms. And I love Qt, which makes coding a pleasure. Although not worked on very big projects (That's why GSoC!), I have several little programs written in C++/Qt including my graduate project, which are all hosted on Github. Apart from that, I'm always curious about language implementation details and have read a lot about C++ and Qt internals. These knowledge seems unnecessary on the first sight, but they do help me handle tricky situations when the code goes wrong. CMake and Git are also my friends, which I use on a daily basis. Besides that, I have a strong background on all basic software related fields, such as algorithm, data structure, compiler, computer archetecture and operating systems, as learnt in my undergraduate (Software Engineering, Xi'an Jiaotong University) and graduate (Computer Science, University of Michigan) study.","url":"https://unlimitedcodeworks.xyz/blog/2016/04/23/gsoc-kdevelop-lldb-support/"},{"tags":"misc","title":"全站启用HTTPS兼第一篇非测试文章","text":"虽然一直在准备，然而没想到第一篇正式的文章会是这样呢(苦笑)。 从买下域名开始，差不多已经一年了。 中间因为毕业设计还有出国，这件事就搁置了 最近受到 朋友 刺激才重新开始准备 说起来友链部分也没有做呢 果然开博客不是一件容易的事情 域名的调整 从Namecheap迁移到Cloudflare想要至少部分使用HTTPS 再从Cloudflare迁移回来，因为Cloudflare没法用自定义邮件服务，我的IP又正好处于黑名单不能自己搭邮件服务器 服务器的调整 通过 Let‘s encrypt 获得SSL证书，启用全站HTTPS (终于说到题目) 从Github Page转移到自己的服务器上，也是为了Let's encrypt的认证方便 也许以后还会重新转移到Cloudflare，毕竟自己的小服务器各地访问速度应该还是不如CDN加速的好 主题的修改 找到符合心意的主题不容易 现在的主题经过大幅度修改后还算可以(自认为)，最近真是前端技能猛长 目前主题还不完善，搜索功能导航栏等等还在建设中，以后有机会再完成吧 还是尽快开始写点儿东西会比较好 i18n的处理现在还不完善 现在还是有点儿纠结究竟是做中文，英文还是两者 这个问题也是日后再处理吧，TODO列表永远在变长也是无可奈何不是么 关于文章 一开始应该会先把很久之前刷ACM题的一些题解搬过来吧，至少充下场面什么的 然后是一些自己在做的pet project，想要做的idea的介绍，能吸引一些人气就好了 (虽然也没期待这儿会有什么人气就是了) 也许还会有一些关于我目前在进行的学业上的研究的记录，如果可以的话也会放上来 还有凭心情看情况的一些杂七杂八的东西 关于这个list 曾经看了网上一个短篇推理小说里写到完全用list的方式来写blog，( 这里 ，原链接已经失效所以链了Google搜索的第一个结果) 简直就是不会组织语言还想写blog的我的救星啊 所以虽然不知道能坚持到什么时候，什么程度，还是决定试试看","url":"https://unlimitedcodeworks.xyz/blog/2015/12/08/full-https-now/"},{"tags":"misc","title":"NJUPT 1362 汽车加油行驶问题","text":"嗯。。还是算法复习用到了的，竟然还有OJ上有这道题，所以过了一下 参考是 Candesoft-BLOG 大体思路就是首先分点，记录同一位置不同剩余油量的花费。 int cost [ N + 1 ][ N + 1 ][ K + 1 ]; 然后从起点开始一点一点扩展，分别判断有和没有加油站的情况走到4个方向上是否是更优的花费。有点儿类似Dijkstra最短路的感觉。 #include <iostream> #include <queue> #include <cstring> #include <cstdio> #include <cmath> using namespace std ; #define ll long long //template<typename T> //inline T min(const T& a, const T& b) { return a < b? a:b;} //template<typename T> //inline T max(const T& a, const T& b) { return a > b? a:b;} const int N = 100 ; const int K = 10 ; const int dirs [][ 2 ] = {{ - 1 , 0 }, { 1 , 0 }, { 0 , - 1 }, { 0 , 1 }}; struct Position { int x , y , k ; }; queue < Position > que ; int cm [ N + 1 ][ N + 1 ][ K + 1 ]; int map [ N + 1 ][ N + 1 ]; int inqueue [ N + 1 ][ N + 1 ][ K + 1 ]; int n , k , a , b , c ; bool isValid ( int x , int y ) { if ( x < 1 || x > n || y < 1 || y > n ) { return false ; } return true ; } void init () { memset ( cm , - 1 , sizeof ( cm )); cm [ 1 ][ 1 ][ k ] = 0 ; memset ( map , 0 , sizeof ( map )); memset ( inqueue , 0 , sizeof ( inqueue )); while ( ! que . empty ()) { que . pop (); } } void checkBetter ( int x , int y , int k , int cost ) { // If is better to go to (x, y) from (p.x, p.y) if ( cm [ x ][ y ][ k ] == - 1 || cm [ x ][ y ][ k ] > cost ) { cm [ x ][ y ][ k ] = cost ; if ( inqueue [ x ][ y ][ k ] == 0 ) { Position tem ; tem . x = x ; tem . y = y ; tem . k = k ; que . push ( tem ); inqueue [ tem . x ][ tem . y ][ tem . k ] = 1 ; } } } int driveCar () { Position pos ; pos . x = pos . y = 1 ; pos . k = k ; inqueue [ 1 ][ 1 ][ k ] = 1 ; que . push ( pos ); while ( ! que . empty ()) { Position p = que . front (); que . pop (); inqueue [ p . x ][ p . y ][ p . k ] = 0 ; for ( int d = 0 ; d != 4 ; d ++ ) { int dx = dirs [ d ][ 0 ], dy = dirs [ d ][ 1 ]; int x = p . x + dx , y = p . y + dy ; if ( isValid ( x , y )) { int cost = cm [ p . x ][ p . y ][ p . k ]; if ( dx < 0 ) { cost += b ; } if ( dy < 0 ) { cost += b ; } // No station. if ( p . k > 0 && map [ p . x ][ p . y ] == 0 ) { // If is better to go to (x, y) from (p.x, p.y) checkBetter ( x , y , p . k - 1 , cost ); } // Has station, ether a new built one, or one already exists. cost += a ; if ( map [ p . x ][ p . y ] == 0 ) { cost += c ; } // Add fuel and check again checkBetter ( x , y , k - 1 , cost ); } } } int mincost = 0x7fffffff ; for ( int i = 0 ; i <= k ; i ++ ) { if ( cm [ n ][ n ][ i ] > 0 && mincost > cm [ n ][ n ][ i ]) { mincost = cm [ n ][ n ][ i ]; } } return mincost ; } int main () { #ifdef ACM_LOCAL freopen ( \"input.txt\" , \"r\" , stdin ); //freopen(\"output.txt\", \"w\", stdout); #endif // ACM_LOCAL while ( scanf ( \"%d%d%d%d%d\" , & n , & k , & a , & b , & c ) != EOF ) { init (); for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) { scanf ( \"%d\" , & map [ i ][ j ]); } printf ( \"%d \\n \" , driveCar ()); } #ifdef ACM_LOCAL printf ( \"Used time: %lf \\n \" , clock () / ( double ) CLOCKS_PER_SEC ); #endif // ACM_LOCAL return 0 ; } 速度还是挺快的： 不过Candesoft-BLOG里说的分层图最短路的没有仔细看。","url":"https://unlimitedcodeworks.xyz/blog/2013/12/23/njupt-1362-qi-che-jia-you-xing-shi-wen-ti/"},{"tags":"misc","title":"带权图模板","text":"使用前向星方法（应该是吧？我着实不确定这种我不知道从哪看到之后一直在用的存储方法究竟叫什么= =）存储的带权图，实现了通用的DFS和BFS算法，可以通过函数对象使用。 正好这两天复习算法，所以整理了一下。有些时候有这么一个模板还是挺方便的说。 直接上代码了 struct ForwardStarWGraph ; struct Node ; struct CallbackFunctor { virtual bool shouldExtend ( ForwardStarWGraph & graph , Node & toExtend ) = 0 ; virtual bool operator () ( ForwardStarWGraph & graph , Node & curr ) = 0 ; }; struct Node { int i ; int from ; int edge ; int totalWight ; vector < int > path ; }; const int N = 20 ; // max vertex conut const int M = N * N ; // max edge count struct ForwardStarWGraph { int to [ M ], nxt [ M ], head [ N ]; int wight [ M ]; int ecnt ; // Actual vertex number int n ; void graphInit ( int nn , int m ) { ecnt = 0 ; n = nn ; memset ( head , - 1 , sizeof ( head )); } // Add an edge, vertex counts from 0 void addEdge ( int u , int v , int w ) { to [ ecnt ] = v ; wight [ ecnt ] = w ; nxt [ ecnt ] = head [ u ]; head [ u ] = ecnt ; ecnt ++ ; } // Add an undirectional edge void addBiEdge ( int u , int v , int w ) { addEdge ( u , v , w ); addEdge ( v , u , w ); } int wightBetween ( int a , int b ) { if ( a == b ) return 0 ; for ( int e = head [ a ]; e != - 1 ; e = nxt [ e ]) { if ( to [ e ] == b ) return wight [ e ]; } return - 1 ; } void bfs ( CallbackFunctor & func ) { queue < Node > Q ; Node tem ; tem . i = 0 ; tem . from = - 1 ; tem . edge = - 1 ; tem . totalWight = 0 ; tem . path . push_back ( 0 ); Q . push ( tem ); while ( ! Q . empty ()) { Node t = Q . front (); Q . pop (); func ( * this , t ); for ( int e = head [ t . i ]; e != - 1 ; e = nxt [ e ]) { if ( to [ e ] == t . from ) continue ; Node t2 ; t2 . i = to [ e ]; t2 . from = t . i ; t2 . edge = e ; t2 . totalWight = t . totalWight + wight [ e ]; t2 . path = t . path ; t2 . path . push_back ( t2 . i ); if ( func . shouldExtend ( * this , t2 )) { Q . push ( t2 ); } } } } void dfs ( CallbackFunctor & func ) { stack < Node > Q ; Node tem ; tem . i = 0 ; tem . from = - 1 ; tem . edge = - 1 ; tem . totalWight = 0 ; tem . path . push_back ( 0 ); Q . push ( tem ); while ( ! Q . empty ()) { Node t = Q . top (); Q . pop (); func ( * this , t ); for ( int e = head [ t . i ]; e != - 1 ; e = nxt [ e ]) { if ( to [ e ] == t . from ) continue ; Node t2 ; t2 . i = to [ e ]; t2 . from = t . i ; t2 . edge = e ; t2 . totalWight = t . totalWight + wight [ e ]; t2 . path = t . path ; t2 . path . push_back ( t2 . i ); if ( func . shouldExtend ( * this , t2 )) { Q . push ( t2 ); } } } } }; 附带一个测试小程序 int n , m ; ForwardStarWGraph g ; struct Routine : CallbackFunctor { virtual bool shouldExtend ( ForwardStarWGraph & graph , Node & toExtend ) { return true ; } virtual bool operator () ( ForwardStarWGraph & graph , Node & curr ) { cout << curr . i + 1 << endl ; } }; int main () { #ifdef ACM_LOCAL freopen ( \"input.txt\" , \"r\" , stdin ); //freopen(\"output.txt\", \"w\", stdout); #endif // ACM_LOCAL while ( scanf ( \"%d %d\" , & n , & m ) != EOF ) { g . graphInit ( n , m ); for ( int i = 0 ; i != m ; i ++ ) { int a , b , w ; scanf ( \"%d%d%d\" , & a , & b , & w ); g . addBiEdge ( a - 1 , b - 1 , w ); } Routine routine ; g . bfs ( routine ); } #ifdef ACM_LOCAL printf ( \"Used time: %lf \\n \" , clock () / ( double ) CLOCKS_PER_SEC ); #endif // ACM_LOCAL return 0 ; }","url":"https://unlimitedcodeworks.xyz/blog/2013/12/22/weighted-graph-template/"},{"tags":"misc","title":"USACO 3.1.4 Shaping Regions","text":"比较基础的矩形切割，是POJ 2528 Mayor's posters的二维版。 还是要注意边缘的情况，比如当(0,8)(18,18) 切割(18,0)(19,19)的时候，结果应该是得到三个矩形 (18,19)(18,19) --> 面积为1 (19,0)(19,19) --> 面积为20 (18,0)(18,7) --> 面积为8 恩，其实我一直没搞懂为啥给数据的时候llx和lly是真正的坐标值，而urx和ury却必须减一之后再用... /* ID: xjtuacm1 PROG: rect1 LANG: C++ */ #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<set> #include<map> #include<vector> #include<cmath> using namespace std ; const int M = 100000 ; const int N = 1000 ; struct rect { int llx , lly ; int urx , ury ; int color ; rect ( int lx = 0 , int ly = 0 , int rx = 0 , int ry = 0 , int c = 0 ) : llx ( lx ), lly ( ly ), urx ( rx ), ury ( ry ), color ( c ) {} int S () { return ( urx - llx + 1 ) * ( ury - lly + 1 ); } } rects [ M ], cur ; int tot ; inline bool cross ( const rect & r1 , const rect & r2 ) { return ! ( ( r1 . llx > r2 . urx ) || ( r1 . urx < r2 . llx ) || ( r1 . lly > r2 . ury ) || ( r1 . ury < r2 . lly )); } inline void add ( const rect & t ) { rects [ tot ++ ] = t ; } inline void del ( int idx ) { rects [ idx ] = rects [ -- tot ]; } void cut ( const rect & t , bool vertical = false ) { int k1 , k2 ; rect tem = t ; if ( vertical ) { k1 = max ( t . lly , cur . lly ); k2 = min ( t . ury , cur . ury ); if ( t . lly < k1 ) { tem . ury = k1 - 1 ; add ( tem ); } if ( k2 < t . ury ) { tem = t , tem . lly = k2 + 1 ; add ( tem ); } } else { k1 = max ( t . llx , cur . llx ); k2 = min ( t . urx , cur . urx ); if ( t . llx < k1 ) { tem . urx = k1 - 1 ; add ( tem ); } if ( t . urx > k2 ) { tem = t , tem . llx = k2 + 1 ; add ( tem ); } tem = t , tem . llx = k1 , tem . urx = k2 ; cut ( tem , true ); } } int main ( int argc , char * argv []) { #ifdef ACM_LOCAL // Local freopen ( \"in\" , \"r\" , stdin ); #else #ifndef ONLINE_JUDGE // not HDOJ / POJ freopen ( \"rect1.in\" , \"r\" , stdin ); freopen ( \"rect1.out\" , \"w\" , stdout ); #endif #endif int a , b , n ; scanf ( \"%d %d %d\" , & a , & b , & n ); add ( rect ( 0 , 0 , a - 1 , b - 1 , 1 )); // add the white sheet first. while ( n -- ) { scanf ( \"%d %d %d %d %d\" , & cur . llx , & cur . lly , & cur . urx , & cur . ury , & cur . color ); cur . urx -- , cur . ury -- ; for ( int i = tot - 1 ; i >= 0 ; i -- ) { if ( cross ( cur , rects [ i ])) { cut ( rects [ i ]); del ( i ); } } add ( cur ); } map < int , int > cnt ; for ( int i = 0 ; i != tot ; i ++ ) { cnt [ rects [ i ]. color ] += rects [ i ]. S (); } for ( map < int , int >:: iterator it = cnt . begin (); it != cnt . end (); it ++ ) { if ( it -> second ) printf ( \"%d %d \\n \" , it -> first , it -> second ); } return 0 ; } BTW, 果然学新的算法就要跟着代码一行一行调试～虽然感觉上慢了点但是可以掌握透彻～ 还有，IOI国家集训队论文2004年薛茅的讲线段树跟矩形切割的，很清楚， 链接在这里 。","url":"https://unlimitedcodeworks.xyz/blog/2013/02/16/usaco-314-shaping-regions/"},{"tags":"misc","title":"POJ 2528 Mayor's posters","text":"这一题多数用的是线段树+离散化，但是今天正好看到矩阵切割，所以就用矩阵切割试了一下。 参考了http://www.2cto.com/kf/201209/156711.html的代码，进行了一些修改，个人感觉更简洁且比较容易理解 #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<set> #include<map> #include<vector> #include<cmath> using namespace std ; const int M = 100000 ; const int N = 10000 ; struct line { int l , r ; int color ; line ( int ll = 0 , int rr = 0 , int c = 0 ) : l ( ll ), r ( rr ), color ( c ) {} } post [ M ], cur ; int tot ; bool used [ N ]; inline bool cross ( const line & l1 , const line & l2 ) { return ! ( ( l1 . l > l2 . r ) || ( l1 . r < l2 . l )); } inline void add ( const line & t ) { post [ tot ++ ] = t ; } void cut ( const line & t ) { if ( t . l < cur . l ) { add ( line ( t . l , cur . l - 1 , t . color )); } if ( t . r > cur . r ) { add ( line ( cur . r + 1 , t . r , t . color )); } } int main ( int argc , char * argv []) { #ifdef ACM_LOCAL // Local freopen ( \"in\" , \"r\" , stdin ); #else #ifndef ONLINE_JUDGE // not HDOJ / POJ freopen ( \"humble.in\" , \"r\" , stdin ); freopen ( \"humble.out\" , \"w\" , stdout ); #endif #endif int ncase ; scanf ( \"%d\" , & ncase ); while ( ncase -- ) { tot = 0 ; int color = 0 ; int n ; scanf ( \"%d\" , & n ); while ( n -- ) { scanf ( \"%d %d\" , & cur . l , & cur . r ); cur . color = color ++ ; // 倒序，否则在cut操作中增加的线段也会再被检查一遍 for ( int i = tot - 1 ; i >= 0 ; i -- ) { if ( cross ( post [ i ], cur )) { cut ( post [ i ]); post [ i ] = post [ -- tot ]; } } add ( cur ); } memset ( used , false , sizeof ( used )); int cnt = 0 ; for ( int i = 0 ; i != tot ; i ++ ) { if ( ! used [ post [ i ]. color ]) { used [ post [ i ]. color ] = true ; cnt ++ ; } } printf ( \"%d \\n \" , cnt ); } return 0 ; } BTW，按说注释中提到的那个循环改成顺序的应该也可以的，只是会慢一些，但实际提交了却是RE。目前还不清楚原因。","url":"https://unlimitedcodeworks.xyz/blog/2013/02/16/poj-2528-mayors-posters/"},{"tags":"misc","title":"USACO 3.1.1 Agri-Net","text":"标准的最小生成树，用了Kruskal算法，写了一个可以以后用的并查集类。 /* ID: xjtuacm1 PROG: agrinet LANG: C++ */ #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<set> #include<map> #include<vector> #include<cmath> using namespace std ; const int MAXDIS = 100000 + 10 ; const int N = 100 ; const int M = N * ( N - 1 ) / 2 ; int n , m ; int e ; int u [ M ], v [ M ], w [ M ]; int wr [ M ]; void initGraph () { e = 0 ; } void addEdge ( int x , int y , int cost ) { u [ e ] = x ; v [ e ] = y ; w [ e ++ ] = cost ; } class UnionFind { int n ; int fa [ N ]; int r [ N ]; public : UnionFind ( int nn ) : n ( nn ) { init (); } void init () { memset ( r , 0 , sizeof ( r )); for ( int i = 0 ; i != n ; i ++ ) fa [ i ] = i ; } int Find ( int x ) { if ( x != fa [ x ]) { fa [ x ] = Find ( fa [ x ]); } return fa [ x ]; } void Union ( int x , int y ) { Link ( Find ( x ), Find ( y )); } private : void Link ( int x , int y ) { if ( r [ x ] > r [ y ]) { fa [ y ] = x ; } else { fa [ x ] = y ; if ( r [ x ] == r [ y ]) r [ y ] ++ ; } } }; bool cmp ( int a , int b ) { return w [ a ] < w [ b ]; } int kruskal () { UnionFind uf ( n ); for ( int i = 0 ; i != m ; i ++ ) wr [ i ] = i ; int ret = 0 ; sort ( wr , wr + m , cmp ); for ( int i = 0 ; i != m ; i ++ ) { int ed = wr [ i ]; if ( uf . Find ( u [ ed ]) != uf . Find ( v [ ed ])) { ret += w [ ed ]; uf . Union ( u [ ed ], v [ ed ]); } } return ret ; } int main ( int argc , char * argv []) { #ifdef ACM freopen ( \"in\" , \"r\" , stdin ); #else freopen ( \"agrinet.in\" , \"r\" , stdin ); freopen ( \"agrinet.out\" , \"w\" , stdout ); #endif // ACM scanf ( \"%d\" , & n ); m = n * ( n - 1 ) / 2 ; for ( int i = 0 ; i != n ; i ++ ) for ( int j = 0 ; j != n ; j ++ ) { int t ; scanf ( \"%d\" , & t ); if ( i > j ) addEdge ( i , j , t ); } printf ( \"%d \\n \" , kruskal ()); return 0 ; }","url":"https://unlimitedcodeworks.xyz/blog/2013/02/15/usaco-311-agri-net/"},{"tags":"misc","title":"USACO 2.4.3 Cow Tours","text":"floyd + dfs染色。 重点是添加新的边之后的field的直径等于 1.原来两个field的直径 2.新的边长加从它的两个端点可以延伸的最大长度 这其中的最大值。 /* ID: xjtuacm1 PROG: cowtour LANG: C++ */ #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<set> #include<map> #include<vector> #include<cmath> using namespace std ; const int N = 150 ; const double DINF = 1e30 ; struct Point { int x , y ; } pes [ N ]; int adj [ N ][ N ]; int color [ N ]; double dis [ N ][ N ]; double maxDis [ N ]; double dia [ N ]; int n ; void floodfill ( int cur , int tag ) { color [ cur ] = tag ; for ( int i = 0 ; i != n ; i ++ ) { if ( adj [ cur ][ i ] && color [ i ] == - 1 ) { floodfill ( i , tag ); } } } int find_component () { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( color [ i ] == - 1 ) floodfill ( i , cnt ++ ); return cnt ; } double dist ( int a , int b ) { if ( ! adj [ a ][ b ]) return DINF ; return sqrt (( pes [ a ]. x - pes [ b ]. x ) * ( pes [ a ]. x - pes [ b ]. x ) + ( pes [ a ]. y - pes [ b ]. y ) * ( pes [ a ]. y - pes [ b ]. y )); } void floyd () { for ( int i = 0 ; i != n ; i ++ ) for ( int j = 0 ; j != n ; j ++ ) dis [ i ][ j ] = dist ( i , j ); for ( int k = 0 ; k != n ; k ++ ) for ( int i = 0 ; i != n ; i ++ ) for ( int j = 0 ; j != n ; j ++ ) dis [ i ][ j ] = min ( dis [ i ][ j ], dis [ i ][ k ] + dis [ k ][ j ]); } int main ( int argc , char * argv []) { #ifdef ACM freopen ( \"in\" , \"r\" , stdin ); #else freopen ( \"cowtour.in\" , \"r\" , stdin ); freopen ( \"cowtour.out\" , \"w\" , stdout ); #endif // ACM scanf ( \"%d \\n \" , & n ); for ( int i = 0 ; i != n ; i ++ ) { scanf ( \"%d %d \\n \" , & pes [ i ]. x , & pes [ i ]. y ); } for ( int i = 0 ; i != n ; i ++ ) { char line [ N + 1 ]; gets ( line ); for ( int j = 0 ; j != n ; j ++ ) { adj [ i ][ j ] = ( line [ j ] == '0' ? 0 : 1 ); dis [ i ][ j ] = dist ( i , j ); } } memset ( color , - 1 , sizeof ( color )); int ncom = find_component (); floyd (); for ( int i = 0 ; i != ncom ; i ++ ) dia [ i ] = 0 ; for ( int i = 0 ; i != n ; i ++ ) { maxDis [ i ] = 0 ; for ( int j = 0 ; j != n ; j ++ ) { if ( i != j && color [ i ] == color [ j ]) { maxDis [ i ] = max ( maxDis [ i ], dis [ i ][ j ]); } } dia [ color [ i ]] = max ( dia [ color [ i ]], maxDis [ i ]); } double diameter = DINF ; for ( int i = 0 ; i != n ; i ++ ) for ( int j = 0 ; j != n ; j ++ ) { if ( color [ i ] == color [ j ]) continue ; double d1 = 0 ; double d2 = 0 ; for ( int k = 0 ; k != n ; k ++ ) { if ( i != k && color [ i ] == color [ k ]) d1 = max ( d1 , dis [ i ][ k ]); if ( j != k && color [ j ] == color [ k ]) d2 = max ( d2 , dis [ j ][ k ]); } double dist = sqrt ( ( pes [ i ]. x - pes [ j ]. x ) * ( pes [ i ]. x - pes [ j ]. x ) + ( pes [ i ]. y - pes [ j ]. y ) * ( pes [ i ]. y - pes [ j ]. y ) ); diameter = min ( diameter , max ( dist + d1 + d2 , max ( dia [ color [ i ]], dia [ color [ j ]]))); } printf ( \"%.6lf \\n \" , diameter ); return 0 ; } BTW，对复杂代码的掌控能力还是不够。。虽然这道题有了完整思路，但是写不出完整的代码，最后还是参考了题解才写完...","url":"https://unlimitedcodeworks.xyz/blog/2013/02/15/usaco-243-cow-tours/"},{"tags":"misc","title":"USACO 2.4.4 Bessie Come Home","text":"带权边的Dijkstra /* ID: xjtuacm1 PROG: comehome LANG: C++ */ #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<set> #include<map> using namespace std ; const int INF = 0x3f3f3f3f ; const int M = 10000 ; const int N = 52 ; // Graph structure int n ; int to [ M ], nxt [ M ], head [ N ]; int w [ M ]; bool vis [ N ]; int e ; int dist [ N ]; // Distance array struct cmp { bool operator () ( int a , int b ) { return dist [ a ] > dist [ b ]; } }; void init () { memset ( vis , false , sizeof ( vis )); memset ( head , - 1 , sizeof ( head )); e = 0 ; } void addEdge ( int u , int v , int c ) { to [ e ] = v ; nxt [ e ] = head [ u ]; w [ e ] = c ; head [ u ] = e ++ ; } void addBiEdge ( int u , int v , int c ) { addEdge ( u , v , c ); addEdge ( v , u , c ); } void dijkstra ( int src ) { // Reset distance array memset ( vis , false , sizeof ( vis )); for ( int i = 0 ; i != n ; i ++ ) dist [ i ] = INF ; priority_queue < int , vector < int > , cmp > que ; vis [ src ] = true ; dist [ src ] = 0 ; que . push ( src ); int pnt = src ; for ( int i = 1 ; i != n ; i ++ ) { for ( int j = head [ pnt ]; j != - 1 ; j = nxt [ j ]) { int v = to [ j ]; if ( ! vis [ v ] && dist [ pnt ] + w [ j ] < dist [ v ]) { dist [ v ] = dist [ pnt ] + w [ j ]; que . push ( v ); } } while ( ! que . empty () && vis [ que . top ()]) que . pop (); if ( que . empty ()) break ; pnt = que . top (); que . pop (); vis [ pnt ] = true ; } } set < char > cows ; int r [ N ]; bool indirectCmp ( int a , int b ) { return dist [ a ] < dist [ b ]; } int toIdx ( char ch ) { if ( ch != tolower ( ch )) return ch - 'A' ; else return ch - 'a' + 26 ; } char toChar ( int idx ) { if ( idx < 26 ) return idx + 'A' ; else return idx - 26 + 'a' ; } int main ( int argc , char * argv []) { freopen ( \"comehome.in\" , \"r\" , stdin ); #ifndef USACO freopen ( \"comehome.out\" , \"w\" , stdout ); #endif // USACO int p ; scanf ( \"%d \\n \" , & p ); n = N ; init (); while ( p -- ) { char f , t ; int c ; scanf ( \"%c %c %d \\n \" , & f , & t , & c ); if ( f == t ) continue ; bool flag = false ; for ( int edge = head [ toIdx ( f )]; edge != - 1 ; edge = nxt [ edge ]) if ( to [ edge ] == ( toIdx ( t ))) { w [ edge ] = min ( w [ edge ], c ); flag = true ; break ; } for ( int edge = head [ toIdx ( t )]; edge != - 1 ; edge = nxt [ edge ]) if ( to [ edge ] == ( toIdx ( f ))) { w [ edge ] = min ( w [ edge ], c ); flag = true ; break ; } if ( flag ) continue ; addBiEdge ( toIdx ( f ), toIdx ( t ), c ); } dijkstra ( toIdx ( 'Z' )); for ( int i = 0 ; i != n ; i ++ ) r [ i ] = i ; sort ( r , r + n , indirectCmp ); for ( int i = 1 ; i != n ; i ++ ) { if ( r [ i ] < 26 ) { printf ( \"%c %d \\n \" , toChar ( r [ i ]), dist [ r [ i ]]); break ; } } return 0 ; }","url":"https://unlimitedcodeworks.xyz/blog/2013/02/15/usaco-244-bessie-come-home/"},{"tags":"misc","title":"USACO 2.4.2 Overfencing","text":"题意是给你一个迷宫，有两个出口，找出最长的从迷宫内任意一点到出口的最短距离。 一开始想到的是dijkstra，在两个出口分别运行一次，取每个点到两个出口距离中最短的，再去其中最大的即可。 然后想到其实分别从两个出口作BFS，标注每个点的距离即可。 /* ID: xjtuacm1 PROG: maze1 LANG: C++ */ #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<set> #include<map> using namespace std ; const int W = 38 ; const int H = 100 ; const int INF = 0x3f3f3f3f ; const int dir [ 4 ] = { 1 , 2 , 4 , 8 }; int stage [ H ][ W ]; int color [ H ][ W ]; int h , w ; struct Point { int x , y ; Point ( int xx = 0 , int yy = 0 ) : x ( xx ), y ( yy ) {} bool operator < ( const Point & rhs ) const { if ( x == rhs . x ) return y < rhs . y ; return x < rhs . x ; } bool connect ( int d ) const { return ! ( stage [ x ][ y ] & dir [ d ]); } Point next ( int d ) const { switch ( dir [ d ]) { case 1 : return Point ( x , y - 1 ); case 2 : return Point ( x - 1 , y ); case 4 : return Point ( x , y + 1 ); case 8 : return Point ( x + 1 , y ); } return Point (); } }; void init () { for ( int i = 0 ; i != h ; i ++ ) for ( int j = 0 ; j != w ; j ++ ) { stage [ i ][ j ] = 0xF ; color [ i ][ j ] = INF ; } } void addEdge ( const Point & u , const Point & v ) { const Point & a = u < v ? u : v ; const Point & b = u < v ? v : u ; if ( a . x == b . x ) { stage [ a . x ][ a . y ] &#94;= 1 << 2 ; stage [ b . x ][ b . y ] &#94;= 1 ; } if ( a . y == b . y ) { stage [ a . x ][ a . y ] &#94;= 1 << 3 ; stage [ b . x ][ b . y ] &#94;= 1 << 1 ; } } void bfs ( const Point & src ) { color [ src . x ][ src . y ] = 1 ; queue < pair < Point , int > > que ; que . push ( make_pair ( src , 1 )); while ( ! que . empty ()) { Point pt = que . front (). first ; int dis = que . front (). second ; que . pop (); for ( int i = 0 ; i != 4 ; i ++ ) { if ( pt . connect ( i )) { Point nxt = pt . next ( i ); if ( dis + 1 < color [ nxt . x ][ nxt . y ]) { color [ nxt . x ][ nxt . y ] = dis + 1 ; que . push ( make_pair ( nxt , color [ nxt . x ][ nxt . y ])); } } } } } int main ( int argc , char * argv []) { freopen ( \"maze1.in\" , \"r\" , stdin ); #ifndef USACO freopen ( \"maze1.out\" , \"w\" , stdout ); #endif // USACO scanf ( \"%d %d\" , & w , & h ); getchar (); init (); Point extCell [ 2 ]; int extCnt = 0 ; char line [ 2 * W + 2 ]; // first line gets ( line ); for ( int i = 0 ; i != strlen ( line ); i ++ ) { if ( line [ i ] == ' ' ) extCell [ extCnt ++ ] = Point ( 0 , ( i - 1 ) / 2 ); } for ( int i = 0 ; i != 2 * h - 1 ; i ++ ) { gets ( line ); if ( i & 1 ) { for ( int j = 0 ; j != strlen ( line ); j ++ ) { if ( line [ j ] == ' ' ) { addEdge ( Point (( i - 1 ) / 2 , ( j - 1 ) / 2 ), Point (( i + 1 ) / 2 , ( j - 1 ) / 2 ) ); } } } else { if ( line [ 0 ] == ' ' ) { extCell [ extCnt ++ ] = Point ( i / 2 , 0 ); } if ( line [ strlen ( line ) - 1 ] == ' ' ) { extCell [ extCnt ++ ] = Point ( i / 2 , w - 1 ); } for ( int j = 2 ; j < strlen ( line ) - 1 ; j += 2 ) { if ( line [ j ] == ' ' ) { addEdge ( Point ( i / 2 , j / 2 - 1 ), Point ( i / 2 , j / 2 ) ); } } } } // last line gets ( line ); for ( int i = 0 ; i != strlen ( line ); i ++ ) { if ( line [ i ] == ' ' ) extCell [ extCnt ++ ] = Point ( h - 1 , ( i - 1 ) / 2 ); } bfs ( extCell [ 0 ]); bfs ( extCell [ 1 ]); int m = 0 ; for ( int i = 0 ; i != h ; i ++ ) for ( int j = 0 ; j != w ; j ++ ) m = max ( m , color [ i ][ j ]); printf ( \"%d \\n \" , m ); return 0 ; }","url":"https://unlimitedcodeworks.xyz/blog/2013/02/15/usaco-242-overfencing/"},{"tags":"misc","title":"HDU 3234 Exclusive-OR","text":"扩展的并查集，参考了以下两个，结合了一下，然后对Query的部分有一些改动，主要是用了map来判断出现次数的奇偶 http://www.cppblog.com/Yuan/archive/2010/09/02/125667.html?opt=admin http://blog.csdn.net/acm_cxlove/article/details/8101710 X1...Xn-1 ，这是题中所说的未给出的 n 个数，维护一个带权的并查集，每个点有一个权 w 保证有 w[k] = Xk &#94; Xfa[k] ， Xfa[k] 表示 Xk 的父亲。 对于 I p q v 则对 p , q 进行Union操作，并利用 v 维护各自的权 w 对于 I p v 可以加入虚拟节点 n ，令 Xn = 0 ， 这样任意以该节点为父亲的节点均有 w[k] = Xk ; 这样就转化成 I p n v 了 而对于每次查询 Q k p1 p2 ... pk 结果 ans = Xp1 &#94; Xp2 &#94; ... &#94; Xpk = w[p1] &#94; w[p2] &#94; ... &#94; w[pk] &#94; (Xfa[p1] &#94; Xfa[p2] &#94; ... &#94; Xfa[pk]) . 这里利用了性质： 任取整数a，有 a &#94; a = 0; a &#94; 0 = a; 又因为 w[p1] ... w[pk] 是已知的, 只需判断 Xfa[p1] ... Xfa[pk] 是否已知即可，即看这些节点是否以Xn为根。 注意的一点是 Xfa[p1] ... Xfa[pk] 中会有重复的，只要出现了偶数次就不用计算，只用考虑出现奇数次的就行了。 另一点注意的是输入输出的形式以及输入行尾换行符的处理，我就在这个地方WA了n多次= = #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<map> using namespace std ; const int N = 20000 + 1 ; const int K = 15 ; const int LINELEN = 150 ; int fa [ N ], w [ N ]; int n , q ; int nfacts ; char line [ LINELEN ]; void init () { for ( int i = 0 ; i <= n ; i ++ ) fa [ i ] = i ; memset ( w , 0 , sizeof ( w )); nfacts = 0 ; } int Find ( int x ) { if ( x != fa [ x ]) { int t = fa [ x ]; fa [ x ] = Find ( fa [ x ]); w [ x ] &#94;= w [ t ]; } return fa [ x ]; } bool Union ( int p , int q , int v ) { int rp = Find ( p ); int rq = Find ( q ); if ( rp == rq ) { return v == ( w [ p ] &#94; w [ q ]); } if ( rp == n ) swap ( rp , rq ); fa [ rp ] = rq ; w [ rp ] = w [ p ] &#94; w [ q ] &#94; v ; return true ; } bool info ( int a , int b , int c ) { bool rt = Union ( a , b , c ); if ( ! rt ) printf ( \"The first %d facts are conflicting. \\n \" , nfacts ); return ! rt ; } int main ( int argc , char * argv []) { #ifdef ACM freopen ( \"ttwo.in\" , \"r\" , stdin ); #endif // ACM int ncase = 1 ; while ( scanf ( \"%d %d\" , & n , & q ), n != 0 || q != 0 ) { printf ( \"Case %d: \\n \" , ncase ++ ); init (); bool conflict = false ; while ( q -- ) { char tp [ 5 ]; scanf ( \"%s\" , tp ); if ( tp [ 0 ] == 'I' ) { nfacts ++ ; getchar (); gets ( line ); int a , b , c ; int rt = sscanf ( line , \"%d %d %d\" , & a , & b , & c ); if ( rt == 2 ) { c = b ; b = n ; } if ( conflict ) continue ; conflict = info ( a , b , c ); } else if ( tp [ 0 ] == 'Q' ) { int k ; int para ; map < int , bool > fas ; bool known = true ; int ans = 0 ; scanf ( \"%d\" , & k ); for ( int i = 0 ; i != k ; i ++ ) { scanf ( \"%d\" , & para ); if ( conflict ) continue ; fas [ Find ( para )] = ! fas [ Find ( para )]; ans &#94;= w [ para ]; } if ( conflict ) continue ; for ( map < int , bool >:: iterator it = fas . begin (); it != fas . end (); it ++ ) { if ( it -> second ) { ans &#94;= w [ it -> first ]; if ( ! ( known = ( Find ( it -> first ) == n ))) break ; } } if ( ! known ) { puts ( \"I don't know.\" ); } else { printf ( \"%d \\n \" , ans ); } } } putchar ( '\\n' ); } return 0 ; } BTW，做惯了USACO，发现对这种复杂的IO真心不习惯了= =，WA了何止10次啊.............= = 最后的问题竟然是.............Case的C忘了大写= =...........................................","url":"https://unlimitedcodeworks.xyz/blog/2013/02/07/hdu-3234-exclusive-or/"},{"tags":"misc","title":"USACO 2.4.1 The Tamworth Two","text":"牛和农夫按照固定的走法在10x10的地图中走，每分钟走一步，求经过几分钟相遇。永远不能相遇输出0。 纯模拟的题。 判断永远不能相遇的方法是如果遇到了一个先前的状态，那么肯定存在循环，必定不能相遇。 程序中把状态表示为牛和农夫的位置以及面向的方向，通过map判断是否遇到重复状态，因为map中不存在的键会有默认值，对于bool来说就是false。 一点点空间的优化是地图只用存一份，牛和农夫不显示在地图上，尽通过状态里的点间接表示。 /* ID: xjtuacm1 PROG: ttwo LANG: C++ */ #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<map> using namespace std ; const int N = 10 ; enum direction { NORTH , EAST , SOUTH , WEST }; struct point { int x , y ; point ( int xx = 0 , int yy = 0 ) : x ( xx ), y ( yy ) {} void set ( int xx , int yy ) { x = xx ; y = yy ; } bool operator == ( const point & pt ) const { return x == pt . x && y == pt . y ; } }; struct state { int d [ 2 ]; point pt [ 2 ]; state () { d [ 0 ] = d [ 1 ] = NORTH ; } bool operator < ( const state & s ) const { return memcmp ( this , & s , sizeof ( state )) < 0 ; } }; map < state , bool > h ; char pane [ N ][ N ]; inline bool inRange ( point pt ) { return pt . x >= 0 && pt . x < 10 && pt . y >= 0 && pt . y < 10 ; } bool met ( const state & s ) { return s . pt [ 0 ] == s . pt [ 1 ]; } void next ( state & s ) { point npt [ 2 ]; for ( int i = 0 ; i != 2 ; i ++ ) { switch ( s . d [ i ]) { case NORTH : npt [ i ]. set ( s . pt [ i ]. x - 1 , s . pt [ i ]. y ); break ; case EAST : npt [ i ]. set ( s . pt [ i ]. x , s . pt [ i ]. y + 1 ); break ; case SOUTH : npt [ i ]. set ( s . pt [ i ]. x + 1 , s . pt [ i ]. y ); break ; case WEST : npt [ i ]. set ( s . pt [ i ]. x , s . pt [ i ]. y - 1 ); break ; } if ( inRange ( npt [ i ]) && pane [ npt [ i ]. x ][ npt [ i ]. y ] != '*' ) { s . pt [ i ] = npt [ i ]; } else { s . d [ i ] += 1 ; s . d [ i ] %= 4 ; } } } int main ( int argc , char * argv []) { freopen ( \"ttwo.in\" , \"r\" , stdin ); #ifndef USACO freopen ( \"ttwo.out\" , \"w\" , stdout ); #endif // USACO state s ; for ( int i = 0 ; i != N ; i ++ ) for ( int j = 0 ; j != N ; j ++ ) { scanf ( \"%c\" , & pane [ i ][ j ]); if ( pane [ i ][ j ] == '\\n' ) scanf ( \"%c\" , & pane [ i ][ j ]); if ( pane [ i ][ j ] == 'F' || pane [ i ][ j ] == 'C' ) { int t = ( pane [ i ][ j ] - 'C' == 0 ? 0 : 1 ); s . pt [ t ]. set ( i , j ); pane [ i ][ j ] = '.' ; } } int minute = 0 ; h [ s ] = true ; while ( ! met ( s )) { next ( s ); if ( h [ s ]) { printf ( \"0 \\n \" ); return 0 ; } h [ s ] = true ; minute ++ ; } printf ( \"%d \\n \" , minute ); return 0 ; } BTW，纯模拟真心考验细心程度= =。。。。","url":"https://unlimitedcodeworks.xyz/blog/2013/02/05/usaco-241-the-tamworth-two/"},{"tags":"misc","title":"USACO 2.3.5 Controlling Companies","text":"恩，暴力解决。 参考了http://haipeng31.blog.163.com/blog/static/105623344201011984618863/ 主要是changed变量的使用。 /* ID: xjtuacm1 PROG: concom LANG: C++ */ #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> using namespace std ; const int CMAX = 100 + 1 ; int comp [ CMAX ][ CMAX ]; bool owns [ CMAX ][ CMAX ]; int main ( int argc , char * argv []) { freopen ( \"concom.in\" , \"r\" , stdin ); #ifndef USACO freopen ( \"concom.out\" , \"w\" , stdout ); #endif // USACO memset ( comp , 0 , sizeof ( comp )); memset ( owns , false , sizeof ( owns )); int n ; scanf ( \"%d\" , & n ); while ( n -- ) { int i , j ; scanf ( \"%d %d\" , & i , & j ); scanf ( \"%d\" , & comp [ i ][ j ]); } for ( int i = 0 ; i != CMAX ; i ++ ) owns [ i ][ i ] = true ; // First condition for ( int i = 0 ; i != CMAX ; i ++ ) for ( int j = 0 ; j != true ; j ++ ) owns [ i ][ j ] = ( comp [ i ][ j ] >= 50 ); // Second condition. This can be merged with third condition. bool changed = true ; while ( changed ) { changed = false ; for ( int i = 1 ; i != CMAX ; i ++ ) { for ( int j = 1 ; j != CMAX ; j ++ ) { if ( ! owns [ i ][ j ]) { int sum = 0 ; for ( int k = 1 ; k != CMAX ; k ++ ) { if ( owns [ i ][ k ]) sum += comp [ k ][ j ]; } if ( sum >= 50 ) { owns [ i ][ j ] = true ; changed = true ; } } } } } for ( int i = 1 ; i != CMAX ; i ++ ) { for ( int j = 1 ; j != CMAX ; j ++ ) { if ( owns [ i ][ j ] && i != j ) printf ( \"%d %d \\n \" , i , j ); } } return 0 ; } BTW，发现现在碰到暴力的题都有点儿不敢做了。。= =","url":"https://unlimitedcodeworks.xyz/blog/2013/02/05/usaco-235-controlling-companies/"},{"tags":"misc","title":"USACO 2.3.1 Longest Prefix","text":"题目意思就是给定1～200个短的Primitive (长度1～10)，以及一个长字符串 (长度200,000以内)，需要找出由这些Primitive任意重复连接形成的后者的最长前缀。 DP + Trie 设长字符串为seq，基本思路是若seq[0...i]是满足要求的前缀，那么seq[0...i+len]也是满足要求的前缀，len是各个Primitive的长度。 然后就是用Trie优化一下判断seq[i...i+len]是否在Primitive集合的过程。 /* ID: xjtuacm1 PROG: prefix LANG: C++ */ #include<iostream> #include<stack> #include<cstring> #include<cstdio> #include<queue> #include<algorithm> #include<map> #include<set> using namespace std ; const int PRISIZE = 205 ; const int PRILEN = 10 + 1 ; const int SEQLEN = 200005 ; const int LINELEN = 76 + 2 ; struct _trie { int next [ 26 ]; int cnt ; } trie [ PRISIZE * PRILEN ]; int trieNodeCnt ; int trieInit () { memset ( trie , 0 , sizeof ( trie )); trieNodeCnt = 1 ; return 0 ; // trie tree's root } void trieAdd ( int root , const char * str ) { int p = root ; while ( * str ) { if ( trie [ p ]. next [ * str - 'A' ] == 0 ) { trie [ p ]. next [ * str - 'A' ] = trieNodeCnt ++ ; } p = trie [ p ]. next [ * str - 'A' ]; str ++ ; } trie [ p ]. cnt += 1 ; } bool trieSearch ( int root , const char * str , int len ) { int p = root ; for ( int i = 0 ; i != len ; i ++ ) { if ( trie [ p ]. next [ str [ i ] - 'A' ] == 0 ) return false ; p = trie [ p ]. next [ str [ i ] - 'A' ]; } return trie [ p ]. cnt > 0 ; } char seq [ SEQLEN ]; int seqlen = 0 ; bool reach [ SEQLEN ]; // reach[i] = if seq[0...i) (length = i) can be composed from primitives. int main ( int argc , char * argv []) { freopen ( \"prefix.in\" , \"r\" , stdin ); #ifndef USACO freopen ( \"prefix.out\" , \"w\" , stdout ); #endif // USACO int root = trieInit (); // root = 0 memset ( reach , false , sizeof ( reach )); char temp [ PRILEN ]; for ( int i = 0 ; i != PRISIZE ; i ++ ) { scanf ( \"%s\" , temp ); if ( temp [ 0 ] == '.' ) break ; trieAdd ( root , temp ); } while ( true ) { scanf ( \"%s\" , seq + seqlen ); int len = strlen ( seq + seqlen ); if ( len == 0 ) break ; seqlen += len ; } for ( int i = 1 ; i != PRILEN ; i ++ ) { reach [ i ] = trieSearch ( root , seq , i ); } for ( int i = 0 ; i != seqlen ; i ++ ) { if ( reach [ i ]) { for ( int j = 1 ; j != PRILEN ; j ++ ) { if ( trieSearch ( root , seq + i , j )) reach [ i + j ] = true ; } } } for ( int i = seqlen ; i != 0 ; i -- ) { if ( reach [ i ]) { printf ( \"%d \\n \" , i ); return 0 ; } } printf ( \"0 \\n \" ); return 0 ; } BTW，这是我第一次写Trie，感觉还挺顺手的。","url":"https://unlimitedcodeworks.xyz/blog/2013/02/05/usaco-231-longest-prefix/"},{"tags":"misc","title":"i18n和l10n的意思","text":"经常在网上看到i18n和l10n的说法，于是很好奇它们的意思 i18n是internationalization (国际化)的缩写,首位的i和末尾的n之间有18个字母,所以简写为i18n 同理l10n是localization (区域化)的缩写","url":"https://unlimitedcodeworks.xyz/blog/2013/02/05/meaning-of-i18n-l10n/"},{"tags":"misc","title":"A really complex markdown test","text":"Overview Philosophy Inline HTML Automatic Escaping for Special Characters Block Elements Paragraphs and Line Breaks Headers Blockquotes Lists Code Blocks Horizontal Rules Span Elements Links Emphasis Code Images Miscellaneous Backslash Escapes Automatic Links Note: This document is itself written using Markdown; you can see the source for it by adding '.text' to the URL . Overview Philosophy Markdown is intended to be as easy-to-read and easy-to-write as is feasible. Readability, however, is emphasized above all else. A Markdown-formatted document should be publishable as-is, as plain text, without looking like it's been marked up with tags or formatting instructions. While Markdown's syntax has been influenced by several existing text-to-HTML filters -- including Setext , atx , Textile , reStructuredText , Grutatext , and EtText -- the single biggest source of inspiration for Markdown's syntax is the format of plain text email. To this end, Markdown's syntax is comprised entirely of punctuation characters, which punctuation characters have been carefully chosen so as to look like what they mean. E.g., asterisks around a word actually look like *emphasis*. Markdown lists look like, well, lists. Even blockquotes look like quoted passages of text, assuming you've ever used email. Inline HTML Markdown's syntax is intended for one purpose: to be used as a format for writing for the web. Markdown is not a replacement for HTML, or even close to it. Its syntax is very small, corresponding only to a very small subset of HTML tags. The idea is not to create a syntax that makes it easier to insert HTML tags. In my opinion, HTML tags are already easy to insert. The idea for Markdown is to make it easy to read, write, and edit prose. HTML is a publishing format; Markdown is a writing format. Thus, Markdown's formatting syntax only addresses issues that can be conveyed in plain text. For any markup that is not covered by Markdown's syntax, you simply use HTML itself. There's no need to preface it or delimit it to indicate that you're switching from Markdown to HTML; you just use the tags. The only restrictions are that block-level HTML elements -- e.g. <div> , <table> , <pre> , <p> , etc. -- must be separated from surrounding content by blank lines, and the start and end tags of the block should not be indented with tabs or spaces. Markdown is smart enough not to add extra (unwanted) <p> tags around HTML block-level tags. For example, to add an HTML table to a Markdown article: This is a regular paragraph. <table> <tr> <td> Foo </td> </tr> </table> This is another regular paragraph. Note that Markdown formatting syntax is not processed within block-level HTML tags. E.g., you can't use Markdown-style *emphasis* inside an HTML block. Span-level HTML tags -- e.g. <span> , <cite> , or <del> -- can be used anywhere in a Markdown paragraph, list item, or header. If you want, you can even use HTML tags instead of Markdown formatting; e.g. if you'd prefer to use HTML <a> or <img> tags instead of Markdown's link or image syntax, go right ahead. Unlike block-level HTML tags, Markdown syntax is processed within span-level tags. Automatic Escaping for Special Characters In HTML, there are two characters that demand special treatment: < and & . Left angle brackets are used to start tags; ampersands are used to denote HTML entities. If you want to use them as literal characters, you must escape them as entities, e.g. &lt; , and &amp; . Ampersands in particular are bedeviling for web writers. If you want to write about 'AT&T', you need to write ' AT&amp;T '. You even need to escape ampersands within URLs. Thus, if you want to link to: http://images.google.com/images?num=30&q=larry+bird you need to encode the URL as: http :// images .google.com / images ? num = 30 & amp ; q = larry + bird in your anchor tag href attribute. Needless to say, this is easy to forget, and is probably the single most common source of HTML validation errors in otherwise well-marked-up web sites. Markdown allows you to use these characters naturally, taking care of all the necessary escaping for you. If you use an ampersand as part of an HTML entity, it remains unchanged; otherwise it will be translated into &amp; . So, if you want to include a copyright symbol in your article, you can write: &copy; and Markdown will leave it alone. But if you write: AT&T Markdown will translate it to: AT&amp;T Similarly, because Markdown supports inline HTML , if you use angle brackets as delimiters for HTML tags, Markdown will treat them as such. But if you write: 4 < 5 Markdown will translate it to: 4 &lt; 5 However, inside Markdown code spans and blocks, angle brackets and ampersands are always encoded automatically. This makes it easy to use Markdown to write about HTML code. (As opposed to raw HTML, which is a terrible format for writing about HTML syntax, because every single < and & in your example code needs to be escaped.) Block Elements Paragraphs and Line Breaks A paragraph is simply one or more consecutive lines of text, separated by one or more blank lines. (A blank line is any line that looks like a blank line -- a line containing nothing but spaces or tabs is considered blank.) Normal paragraphs should not be indented with spaces or tabs. The implication of the \"one or more consecutive lines of text\" rule is that Markdown supports \"hard-wrapped\" text paragraphs. This differs significantly from most other text-to-HTML formatters (including Movable Type's \"Convert Line Breaks\" option) which translate every line break character in a paragraph into a <br /> tag. When you do want to insert a <br /> break tag using Markdown, you end a line with two or more spaces, then type return. Yes, this takes a tad more effort to create a <br /> , but a simplistic \"every line break is a <br /> \" rule wouldn't work for Markdown. Markdown's email-style blockquoting and multi-paragraph list items work best -- and look better -- when you format them with hard breaks. Headers Markdown supports two styles of headers, Setext and atx . Setext-style headers are \"underlined\" using equal signs (for first-level headers) and dashes (for second-level headers). For example: This is an H1 ============= This is an H2 ------------- Any number of underlining = 's or - 's will work. Atx-style headers use 1-6 hash characters at the start of the line, corresponding to header levels 1-6. For example: # This is an H1 ## This is an H2 ###### This is an H6 Optionally, you may \"close\" atx-style headers. This is purely cosmetic -- you can use this if you think it looks better. The closing hashes don't even need to match the number of hashes used to open the header. (The number of opening hashes determines the header level.) : # This is an H1 # ## This is an H2 ## ### This is an H3 ###### Blockquotes Markdown uses email-style > characters for blockquoting. If you're familiar with quoting passages of text in an email message, then you know how to create a blockquote in Markdown. It looks best if you hard wrap the text and put a > before every line: > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, > consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. > Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. > > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse > id sem consectetuer libero luctus adipiscing. Markdown allows you to be lazy and only put the > before the first line of a hard-wrapped paragraph: > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of > : > This is the first level of quoting. > > > This is nested blockquote. > > Back to the first level. Blockquotes can contain other Markdown elements, including headers, lists, and code blocks: > ## This is a header. > > 1. This is the first list item. > 2. This is the second list item. > > Here's some example code: > > return shell_exec(\"echo $ input | $ markdown_script \"); Any decent text editor should make email-style quoting easy. For example, with BBEdit, you can make a selection and choose Increase Quote Level from the Text menu. Lists Markdown supports ordered (numbered) and unordered (bulleted) lists. Unordered lists use asterisks, pluses, and hyphens -- interchangably -- as list markers: * Red * Green * Blue is equivalent to: + Red + Green + Blue and: - Red - Green - Blue Ordered lists use numbers followed by periods: 1. Bird 2. McHale 3. Parish It's important to note that the actual numbers you use to mark the list have no effect on the HTML output Markdown produces. The HTML Markdown produces from the above list is: <ol> <li> Bird </li> <li> McHale </li> <li> Parish </li> </ol> If you instead wrote the list in Markdown like this: 1. Bird 1. McHale 1. Parish or even: 3. Bird 1. McHale 8. Parish you'd get the exact same HTML output. The point is, if you want to, you can use ordinal numbers in your ordered Markdown lists, so that the numbers in your source match the numbers in your published HTML. But if you want to be lazy, you don't have to. If you do use lazy list numbering, however, you should still start the list with the number 1. At some point in the future, Markdown may support starting ordered lists at an arbitrary number. List markers typically start at the left margin, but may be indented by up to three spaces. List markers must be followed by one or more spaces or a tab. To make lists look nice, you can wrap items with hanging indents: * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. But if you want to be lazy, you don't have to: * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. If list items are separated by blank lines, Markdown will wrap the items in <p> tags in the HTML output. For example, this input: * Bird * Magic will turn into: <ul> <li> Bird </li> <li> Magic </li> </ul> But this: * Bird * Magic will turn into: <ul> <li><p> Bird </p></li> <li><p> Magic </p></li> </ul> List items may consist of multiple paragraphs. Each subsequent paragraph in a list item must be indented by either 4 spaces or one tab: 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. It looks nice if you indent every line of the subsequent paragraphs, but here again, Markdown will allow you to be lazy: * This is a list item with two paragraphs. This is the second paragraph in the list item. You're only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. To put a blockquote within a list item, the blockquote's > delimiters need to be indented: * A list item with a blockquote: > This is a blockquote > inside a list item. To put a code block within a list item, the code block needs to be indented twice -- 8 spaces or two tabs: * A list item with a code block: <code goes here> It's worth noting that it's possible to trigger an ordered list by accident, by writing something like this: 1986. What a great season. In other words, a number-period-space sequence at the beginning of a line. To avoid this, you can backslash-escape the period: 1986\\. What a great season. Code Blocks Pre-formatted code blocks are used for writing about programming or markup source code. Rather than forming normal paragraphs, the lines of a code block are interpreted literally. Markdown wraps a code block in both <pre> and <code> tags. To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab. For example, given this input: This is a normal paragraph: This is a code block. Markdown will generate: <p> This is a normal paragraph: </p> <pre><code> This is a code block. </code></pre> One level of indentation -- 4 spaces or 1 tab -- is removed from each line of the code block. For example, this: Here is an example of AppleScript: tell application \"Foo\" beep end tell will turn into: <p> Here is an example of AppleScript: </p> <pre><code> tell application \"Foo\" beep end tell </code></pre> A code block continues until it reaches a line that is not indented (or the end of the article). Within a code block, ampersands ( & ) and angle brackets ( < and > ) are automatically converted into HTML entities. This makes it very easy to include example HTML source code using Markdown -- just paste it and indent it, and Markdown will handle the hassle of encoding the ampersands and angle brackets. For example, this: <div class= \"footer\" > &copy; 2004 Foo Corporation </div> will turn into: <pre><code> &lt; div class=\"footer\" &gt; &amp; copy; 2004 Foo Corporation &lt; /div &gt; </code></pre> Regular Markdown syntax is not processed within code blocks. E.g., asterisks are just literal asterisks within a code block. This means it's also easy to use Markdown to write about Markdown's own syntax. Horizontal Rules You can produce a horizontal rule tag ( <hr /> ) by placing three or more hyphens, asterisks, or underscores on a line by themselves. If you wish, you may use spaces between the hyphens or asterisks. Each of the following lines will produce a horizontal rule: * * * *** ***** - - - --------------------------------------- Span Elements Links Markdown supports two style of links: inline and reference . In both styles, the link text is delimited by [square brackets]. To create an inline link, use a set of regular parentheses immediately after the link text's closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example: This is [ an example ]( http : //example.com/ \"Title\") inline link. [ This link ]( http : //example.net/) has no title attribute. Will produce: <p> This is <a href= \"http://example.com/\" title= \"Title\" > an example </a> inline link. </p> <p><a href= \"http://example.net/\" > This link </a> has no title attribute. </p> If you're referring to a local resource on the same server, you can use relative paths: See my [About](/about/) page for details. Reference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link: This is [ an example ][ id ] reference - style link . You can optionally use a space to separate the sets of brackets: This is [ an example ] [ id ] reference - style link . Then, anywhere in the document, you define your link label like this, on a line by itself: [id]: http://example.com/ \"Optional Title Here\" That is: Square brackets containing the link identifier (optionally indented from the left margin using up to three spaces); followed by a colon; followed by one or more spaces (or tabs); followed by the URL for the link; optionally followed by a title attribute for the link, enclosed in double or single quotes, or enclosed in parentheses. The following three link definitions are equivalent: [foo]: http://example.com/ \"Optional Title Here\" [foo]: http://example.com/ 'Optional Title Here' [foo]: http://example.com/ (Optional Title Here) Note: There is a known bug in Markdown.pl 1.0.1 which prevents single quotes from being used to delimit link titles. The link URL may, optionally, be surrounded by angle brackets: [id]: <http://example.com/> \"Optional Title Here\" You can put the title attribute on the next line and use extra spaces or tabs for padding, which tends to look better with longer URLs: [id]: http://example.com/longish/path/to/resource/here \"Optional Title Here\" Link definitions are only used for creating links during Markdown processing, and are stripped from your document in the HTML output. Link definition names may consist of letters, numbers, spaces, and punctuation -- but they are not case sensitive. E.g. these two links: [link text][a] [link text][A] are equivalent. The implicit link name shortcut allows you to omit the name of the link, in which case the link text itself is used as the name. Just use an empty set of square brackets -- e.g., to link the word \"Google\" to the google.com web site, you could simply write: [Google][] And then define the link: [Google]: http://google.com/ Because link names may contain spaces, this shortcut even works for multiple words in the link text: Visit [ Daring Fireball ][] for more information . And then define the link: [ Daring Fireball ] : http : //daringfireball.net/ Link definitions can be placed anywhere in your Markdown document. I tend to put them immediately after each paragraph in which they're used, but if you want, you can put them all at the end of your document, sort of like footnotes. Here's an example of reference links in action: I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ \"Google\" [2]: http://search.yahoo.com/ \"Yahoo Search\" [3]: http://search.msn.com/ \"MSN Search\" Using the implicit link name shortcut, you could instead write: I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ \"Google\" [yahoo]: http://search.yahoo.com/ \"Yahoo Search\" [msn]: http://search.msn.com/ \"MSN Search\" Both of the above examples will produce the following HTML output: <p> I get 10 times more traffic from <a href= \"http://google.com/\" title= \"Google\" > Google </a> than from <a href= \"http://search.yahoo.com/\" title= \"Yahoo Search\" > Yahoo </a> or <a href= \"http://search.msn.com/\" title= \"MSN Search\" > MSN </a> . </p> For comparison, here is the same paragraph written using Markdown's inline link style: I get 10 times more traffic from [Google](http://google.com/ \"Google\") than from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or [MSN](http://search.msn.com/ \"MSN Search\"). The point of reference-style links is not that they're easier to write. The point is that with reference-style links, your document source is vastly more readable. Compare the above examples: using reference-style links, the paragraph itself is only 81 characters long; with inline-style links, it's 176 characters; and as raw HTML, it's 234 characters. In the raw HTML, there's more markup than there is text. With Markdown's reference-style links, a source document much more closely resembles the final output, as rendered in a browser. By allowing you to move the markup-related metadata out of the paragraph, you can add links without interrupting the narrative flow of your prose. Emphasis Markdown treats asterisks ( * ) and underscores ( _ ) as indicators of emphasis. Text wrapped with one * or _ will be wrapped with an HTML <em> tag; double * 's or _ 's will be wrapped with an HTML <strong> tag. E.g., this input: *single asterisks* _single underscores_ **double asterisks** __double underscores__ will produce: <em> single asterisks </em> <em> single underscores </em> <strong> double asterisks </strong> <strong> double underscores </strong> You can use whichever style you prefer; the lone restriction is that the same character must be used to open and close an emphasis span. Emphasis can be used in the middle of a word: un*frigging*believable But if you surround an * or _ with spaces, it'll be treated as a literal asterisk or underscore. To produce a literal asterisk or underscore at a position where it would otherwise be used as an emphasis delimiter, you can backslash escape it: \\*this text is surrounded by literal asterisks\\* Code To indicate a span of code, wrap it with backtick quotes ( ` ). Unlike a pre-formatted code block, a code span indicates code within a normal paragraph. For example: Use the ` printf () ` function . will produce: <p> Use the <code> printf() </code> function. </p> To include a literal backtick character within a code span, you can use multiple backticks as the opening and closing delimiters: ``There is a literal backtick (`) here.`` which will produce this: <p><code> There is a literal backtick (`) here. </code></p> The backtick delimiters surrounding a code span may include spaces -- one after the opening, one before the closing. This allows you to place literal backtick characters at the beginning or end of a code span: A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` will produce: <p> A single backtick in a code span: <code> ` </code></p> <p> A backtick-delimited string in a code span: <code> `foo` </code></p> With a code span, ampersands and angle brackets are encoded as HTML entities automatically, which makes it easy to include example HTML tags. Markdown will turn this: Please don't use any `<blink>` tags. into: <p> Please don't use any <code> &lt; blink &gt; </code> tags. </p> You can write this: `&#8212;` is the decimal-encoded equivalent of `&mdash;`. to produce: <p><code> &amp; #8212; </code> is the decimal-encoded equivalent of <code> &amp; mdash; </code> . </p> Images Admittedly, it's fairly difficult to devise a \"natural\" syntax for placing images into a plain text document format. Markdown uses an image syntax that is intended to resemble the syntax for links, allowing for two styles: inline and reference . Inline image syntax looks like this: ! [ Alt text ]( / path / to / img . jpg ) ! [ Alt text ]( / path / to / img . jpg \"Optional title\" ) That is: An exclamation mark: ! ; followed by a set of square brackets, containing the alt attribute text for the image; followed by a set of parentheses, containing the URL or path to the image, and an optional title attribute enclosed in double or single quotes. Reference-style image syntax looks like this: ! [ Alt text ][ id ] Where \"id\" is the name of a defined image reference. Image references are defined using syntax identical to link references: [id]: url/to/image \"Optional title attribute\" As of this writing, Markdown has no syntax for specifying the dimensions of an image; if this is important to you, you can simply use regular HTML <img> tags. Miscellaneous Automatic Links Markdown supports a shortcut style for creating \"automatic\" links for URLs and email addresses: simply surround the URL or email address with angle brackets. What this means is that if you want to show the actual text of a URL or email address, and also have it be a clickable link, you can do this: <http://example.com/> Markdown will turn this into: <a href= \"http://example.com/\" > http://example.com/ </a> Automatic links for email addresses work similarly, except that Markdown will also perform a bit of randomized decimal and hex entity-encoding to help obscure your address from address-harvesting spambots. For example, Markdown will turn this: <address@example.com> into something like this: <a href= \"&#x6D;&#x61;i&#x6C;&#x74;&#x6F;:&#x61;&#x64;&#x64;&#x72;&#x65; &#115;&#115;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6C;e&#x2E;&#99;&#111; &#109;\" > &#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61; &#109;&#x70;&#x6C; e &#x2E;&#99;&#111;&#109; </a> which will render in a browser as a clickable link to \"address@example.com\". (This sort of entity-encoding trick will indeed fool many, if not most, address-harvesting bots, but it definitely won't fool all of them. It's better than nothing, but an address published in this way will probably eventually start receiving spam.) Backslash Escapes Markdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown's formatting syntax. For example, if you wanted to surround a word with literal asterisks (instead of an HTML <em> tag), you can use backslashes before the asterisks, like this: \\*literal asterisks\\* Markdown provides backslash escapes for the following characters: \\ backslash ` backtick * asterisk _ underscore {} curly braces [] square brackets () parentheses # hash mark + plus sign - minus sign (hyphen) . dot ! exclamation mark","url":"https://unlimitedcodeworks.xyz/blog/1970/11/18/a-really-complex-markdown-test/"}]}